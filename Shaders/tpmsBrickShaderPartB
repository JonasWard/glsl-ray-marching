}

float sdCookie(vec3 p) {
    float d=sdLine(p, cylinderA, cylinderB)-brickW;

    float d_g=sdPattern(p);
    d+=d_g;
    d=differenceSDF(d, d);

    float d_t=sdPlane(p, planeTop);
    d = intersectSDF(d, d_t);

    d=unionSDF(sdCone(p - pinMidA, csVec), d);
    d=unionSDF(sdCone(p - pinMidB, csVec), d);

    float d_b=sdPlane(p, planeBottom);
    float d_cb=sdPlane(p, planeConeTop);

    d=intersectSDF(d, d_cb);
    d=intersectSDF(d, d_b);

    return d;
}

// mathematical functions
mat2 Rot(float a) {
    float s = sin(a);
    float c = cos(a);
    return mat2(c, -s, s, c);
}

float smin(float a, float b, float k) {
    float h = clamp(.5  + .5 * (b - a) / k, .0, 1.);
    return mix(b, a, h) - k * h * (1.0 - h);
}

float GetDist(vec3 p) {
    // return sdCookie(p);
    p*=ppScale;
    float d=sdCookie(p);
    // d=unionSDF(sdCappedCone(p, pinBStart, pinBEnd, pinBottomR, pinTopR), d);

    d+=sdBands(p);
    return d*ppScale;
}

float RayMarch(vec3 ro, vec3 rd) {
    float d0 = 0.;

    for (int i = 0; i < maxSteps; i++) {
        vec3 p = ro + rd * d0;
        float dS = GetDist(p) * understep;
        d0 += dS;

        if (d0 > maxDist || dS < surfDist) break;
    }

    return d0;
}

vec3 GetNormal(vec3 p)
{
    float d=GetDist(p);// Distance
    vec2 e=vec2(.01,0);// Epsilon
     
    vec3 n=d-vec3(
        GetDist(p-e.xyy),// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));
         
    return normalize(n);
}
float GetLight(vec3 p)
{
    vec3 l=normalize(lightPos-p);// Light Vector
    vec3 n=GetNormal(p);// Normal Vector
     
    float dif=dot(n,l);// Diffuse light
    dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0
     
    // Shadows
    float d=RayMarch(p+n*surfDist*2.,l);
     
    if(d<length(lightPos-p))dif*=.1;
     
    return dif;
}

vec3 R(vec2 uv, vec3 p, vec3 l, float z) {
    vec3 f = normalize(l - p),
        r = normalize(cross(vec3(0, 1, 0), f)),
        u = cross(f, r),
        c = p + f * z,
        i = c + uv.x * r + uv.y * u,
        d = normalize(i - p);
    return d;
}

void main()
{
    vec2 uv = (gl_FragCoord.xy - .5 * resolution.xy) / resolution.y;
    vec2 m = mousePosition / resolution.xy;

    vec3 ro = vec3(5., 1., 0.);
    ro.yx *= Rot(-m.y);
    ro.xz *= Rot(-m.x);
    // ro.xz *= Rot(5.3 + m.x * tau);

    vec3 rd = R(uv, ro, vec3(0), .58);
    float d = RayMarch(ro, rd);

    vec3 n;
    if (d < backgroundD) {
        float l = GetLight(ro+d*rd);
        n = color2 * clamp(l, .5, 1.);
    } else {
        n = color1;
    }
    

    gl_FragColor = vec4(n, 1.);
}