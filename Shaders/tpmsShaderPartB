
}

float HardCodedDistances(vec3 p) {
    float y = p.y / ySpacing;
    float remainder = fract(y + .5);
    float groundedY = y - 10.0 * floor(y / 10.);

    // return remainder;

    if (groundedY < 1.) {
        return v0;
        return v0 + (v1 - v0) * fract(y);
    } else if (groundedY < 2.) {
        return v1;
        return v1 + (v2 - v1) * remainder;
    } else if (groundedY < 3.) {
        return v2;
        return v2 + (v3 - v2) * remainder;
    } else if (groundedY < 4.) {
        return v3;
        return v3 + (v4 - v3) * remainder;
    } else if (groundedY < 5.) {
        return v4;
        return v4 + (v5 - v4) * remainder;
    } else if (groundedY < 6.) {
        return v5;
        return v5 + (v6 - v5) * remainder;
    // } else if (groundedY < 7.) {
    //     return v6;
    //     return v6 + (v7 - v6) * remainder;
    // } else if (groundedY < 8.) {
    //     return v7;
    //     return v7 + (v8 - v7) * remainder;
    // } else if (groundedY < 9.) {
    //     return v8;
    //     return v8 + (v9 - v8) * remainder;
    // } else if (groundedY < 10.) {
    //     return v9;
    //     return v9 + (v0 - v9) * remainder;
    } else {
        // return 0.;
        return GetDist(p);
    }
}


float GetDist(vec2 p) {
    return HardCodedDistances(vec3(p, 0.));
}

vec3 colorFromDistance(float d) {
    // float dRemap = float(floor( ( d * .5 + .5) * steps + .5 ) ) / steps;
    float dRemap = d * .5 + .5;
    vec3 color = mix(color1,color2, dRemap );

    return color;
}

vec3 translate(vec3 p, vec3 mv) {
    return (p + mv);
}

vec3 translate(vec3 p) {
    return translate(p, mvVec);
}

vec2 rotate(vec2 p, float a) {
    return vec2(
        p.x * cos(a) - p.y * sin(a),
        p.x * sin(a) + p.y * cos(a)
    );
}

vec2 rotate(vec2 p) {
    return rotate(p, rotation);
}

void main()
{
    vec2 scaledVec = (gl_FragCoord.xy - base) / zoomLevel - mousePosition;
    scaledVec = rotate(scaledVec);
    // scaledVec = scaledVec - mousePosition;

    vec3 p = vec3(scaledVec, 0.);

    // p = rotate( p );

    float d = HardCodedDistances(p);

    vec3 n = colorFromDistance(d * 2.);

    gl_FragColor = vec4(n, 1.);
}